// src/server_renderer.ts
import { pathToFileURL } from "node:url";
var ServerRenderer = class _ServerRenderer {
  constructor(config, vite) {
    this.config = config;
    this.vite = vite;
  }
  static runtime;
  /**
   * Render the page on the server
   *
   * On development, we use the Vite Runtime API
   * On production, we just import and use the SSR bundle generated by Vite
   */
  async render(pageObject) {
    let render;
    const devServer = this.vite?.getDevServer();
    if (devServer) {
      _ServerRenderer.runtime ??= await this.vite.createRuntime();
      render = await _ServerRenderer.runtime.executeEntrypoint(this.config.ssr.entrypoint);
    } else {
      render = await import(pathToFileURL(this.config.ssr.bundle).href);
    }
    const result = await render.default(pageObject);
    return { head: result.head, body: result.body };
  }
};

// src/inertia.ts
var kLazySymbol = Symbol("lazy");
var Inertia = class {
  constructor(ctx, config, vite) {
    this.ctx = ctx;
    this.config = config;
    this.vite = vite;
    this.#sharedData = config.sharedData;
    this.#serverRenderer = new ServerRenderer(config, vite);
  }
  #sharedData = {};
  #serverRenderer;
  /**
   * Check if a value is a lazy prop
   */
  #isLazyProps(value) {
    return typeof value === "object" && value && kLazySymbol in value;
  }
  /**
   * Pick props to resolve based on x-inertia-partial-data header
   *
   * If header is not present, resolve all props except lazy props
   * If header is present, resolve only the props that are listed in the header
   */
  #pickPropsToResolve(component, props) {
    const partialData = this.ctx.request.header("x-inertia-partial-data")?.split(",").filter(Boolean);
    const partialComponent = this.ctx.request.header("x-inertia-partial-component");
    let entriesToResolve = Object.entries(props);
    if (partialData && partialComponent === component) {
      entriesToResolve = entriesToResolve.filter(([key]) => partialData.includes(key));
    } else {
      entriesToResolve = entriesToResolve.filter(([key]) => !this.#isLazyProps(props[key]));
    }
    return entriesToResolve;
  }
  /**
   * Resolve the props that will be sent to the client
   */
  async #resolvePageProps(component, props) {
    const entriesToResolve = this.#pickPropsToResolve(component, props);
    const entries = entriesToResolve.map(async ([key, value]) => {
      if (typeof value === "function") {
        return [key, await value(this.ctx)];
      }
      if (this.#isLazyProps(value)) {
        const lazyValue = value[kLazySymbol];
        return [key, await lazyValue()];
      }
      return [key, value];
    });
    return Object.fromEntries(await Promise.all(entries));
  }
  /**
   * Build the page object that will be returned to the client
   *
   * See https://inertiajs.com/the-protocol#the-page-object
   */
  async #buildPageObject(component, pageProps) {
    return {
      component,
      version: this.config.versionCache.getVersion(),
      props: await this.#resolvePageProps(component, { ...this.#sharedData, ...pageProps }),
      url: this.ctx.request.url(true)
    };
  }
  /**
   * If the page should be rendered on the server or not
   *
   * The ssr.pages config can be a list of pages or a function that returns a boolean
   */
  async #shouldRenderOnServer(component) {
    const isSsrEnabled = this.config.ssr.enabled;
    if (!isSsrEnabled) return false;
    let isSsrEnabledForPage = false;
    if (typeof this.config.ssr.pages === "function") {
      isSsrEnabledForPage = await this.config.ssr.pages(this.ctx, component);
    } else if (this.config.ssr.pages) {
      isSsrEnabledForPage = this.config.ssr.pages?.includes(component);
    } else {
      isSsrEnabledForPage = true;
    }
    return isSsrEnabledForPage;
  }
  /**
   * Resolve the root view
   */
  #resolveRootView() {
    return typeof this.config.rootView === "function" ? this.config.rootView(this.ctx) : this.config.rootView;
  }
  /**
   * Render the page on the server
   */
  async #renderOnServer(pageObject, viewProps) {
    const { head, body } = await this.#serverRenderer.render(pageObject);
    return this.ctx.view.render(this.#resolveRootView(), {
      ...viewProps,
      page: { ssrHead: head, ssrBody: body, ...pageObject }
    });
  }
  /**
   * Share data for the current request.
   * This data will override any shared data defined in the config.
   */
  share(data) {
    this.#sharedData = { ...this.#sharedData, ...data };
  }
  /**
   * Render a page using Inertia
   */
  async render(component, pageProps, viewProps) {
    const pageObject = await this.#buildPageObject(component, pageProps);
    const isInertiaRequest = !!this.ctx.request.header("x-inertia");
    if (!isInertiaRequest) {
      const shouldRenderOnServer = await this.#shouldRenderOnServer(component);
      if (shouldRenderOnServer) return this.#renderOnServer(pageObject, viewProps);
      return this.ctx.view.render(this.#resolveRootView(), { ...viewProps, page: pageObject });
    }
    this.ctx.response.header("x-inertia", "true");
    return pageObject;
  }
  /**
   * Create a lazy prop
   *
   * Lazy props are never resolved on first visit, but only when the client
   * request a partial reload explicitely with this value.
   *
   * See https://inertiajs.com/partial-reloads#lazy-data-evaluation
   */
  lazy(callback) {
    return { [kLazySymbol]: callback };
  }
  /**
   * This method can be used to redirect the user to an external website
   * or even a non-inertia route of your application.
   *
   * See https://inertiajs.com/redirects#external-redirects
   */
  async location(url) {
    this.ctx.response.header("X-Inertia-Location", url);
    this.ctx.response.status(409);
  }
};

// src/inertia_middleware.ts
var InertiaMiddleware = class {
  constructor(config, vite) {
    this.config = config;
    this.vite = vite;
  }
  async handle(ctx, next) {
    const { response, request } = ctx;
    ctx.inertia = new Inertia(ctx, this.config, this.vite);
    await next();
    const isInertiaRequest = !!request.header("x-inertia");
    if (!isInertiaRequest) return;
    response.header("Vary", "Accept");
    const method = request.method();
    if (response.getStatus() === 302 && ["PUT", "PATCH", "DELETE"].includes(method)) {
      response.status(303);
    }
    const version = this.config.versionCache.getVersion().toString();
    if (method === "GET" && request.header("x-inertia-version", "") !== version) {
      response.header("x-inertia-location", request.url());
      response.status(409);
    }
  }
};

export {
  InertiaMiddleware
};
