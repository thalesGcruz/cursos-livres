{"version":3,"sources":["../src/helpers.ts","../src/tokenizers/main.ts","../src/parser.ts"],"sourcesContent":["/*\n * @poppinss/dumper\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport is from '@sindresorhus/is'\nimport type { Parser } from './parser.js'\n\nconst ObjectPrototype = Object.prototype\nconst ArrayPrototype = Array.prototype\nconst ObjectPrototypeKeys = Reflect.ownKeys(ObjectPrototype)\nconst ArrayPrototypeKeys = Reflect.ownKeys(ArrayPrototype)\n\n/**\n * Helper to tokenize an object and its prototype\n */\nexport function tokenizeObject(\n  value: Record<string | symbol, any>,\n  parser: Parser,\n  config: {\n    depth: number\n    showHidden: boolean\n    collapse: string[]\n    inspectObjectPrototype: boolean | 'unless-plain-object'\n    constructorName?: string\n    membersToIgnore?: (string | symbol)[]\n    eagerGetters?: (string | symbol)[]\n  }\n) {\n  parser.context.objectsSeen = parser.context.objectsSeen ?? new Set()\n  parser.context.depth = parser.context.depth ?? 0\n\n  /**\n   * Handle circular references of the same object and\n   * limit traversing once maxDepth has been reached\n   */\n  if (parser.context.objectsSeen.has(value)) {\n    parser.collect({ type: 'object-circular-ref' })\n    return\n  }\n  if (parser.context.depth >= parser.config.depth) {\n    parser.collect({ type: 'object-max-depth-ref' })\n    return\n  }\n\n  /**\n   * Keep reference of the config properties to avoid\n   * property access inside the for loop\n   */\n  const showHidden = config.showHidden\n\n  /**\n   * Grab metadata of the object.\n   */\n  const name = config.constructorName ?? Object.getPrototypeOf(value)?.constructor.name ?? null\n\n  /**\n   * Do not inspect children when constructor of the\n   * object is meant to be collapsed.\n   */\n  if (config.collapse.includes(name)) {\n    parser.collect({\n      type: 'collapse',\n      name: name,\n      token: {\n        type: 'object-start',\n        constructorName: name,\n      },\n    })\n    return\n  }\n\n  const ownKeys = Reflect.ownKeys(value)\n  const eagerGetters = config.eagerGetters ?? []\n\n  /**\n   * Track seen object and increment depth\n   */\n  parser.context.depth++\n  parser.context.objectsSeen.add(value)\n\n  /**\n   * Create a final collection of keys.\n   *\n   * When we have membersToIgnore, we will delete those members\n   * from final keys set.\n   */\n  let keys: (string | symbol)[] = []\n  if (config.membersToIgnore) {\n    const keysSet = new Set([...ownKeys])\n    config.membersToIgnore.forEach((m) => keysSet.delete(m))\n    keys = Array.from(keysSet)\n  } else {\n    keys = ownKeys\n  }\n\n  parser.collect({ type: 'object-start', constructorName: name })\n\n  /**\n   * Looping over own keys (including non-enumerable)\n   */\n  for (let key of keys) {\n    /**\n     * Ensure property is known\n     */\n    const descriptor = Object.getOwnPropertyDescriptor(value, key)\n    if (!descriptor) {\n      continue\n    }\n\n    /**\n     * Do not show \"enumerable\" properties unless \"showHidden\"\n     * has been enabled.\n     */\n    if (!descriptor.enumerable && !showHidden) {\n      continue\n    }\n\n    /**\n     * Collect key with its meta-data\n     */\n    const isSymbol = typeof key === 'symbol'\n    const isWritable = !!descriptor.set || !!descriptor.writable\n    parser.collect({\n      type: 'object-key',\n      isSymbol,\n      isWritable,\n      value: String(key),\n    })\n\n    /**\n     * Avoiding accessing getters to prevent\n     * side-effects\n     */\n    if ('get' in descriptor && !eagerGetters.includes(key)) {\n      parser.collect({ type: 'object-value-getter' })\n      continue\n    }\n\n    /**\n     * Inspect value\n     */\n    parser.collect({ type: 'object-value-start' })\n    parser.parse(value[key])\n    parser.collect({ type: 'object-value-end' })\n  }\n\n  /**\n   * Tokenize the prototype of an object. Prototypes should\n   * not count against the depth.\n   */\n  if (config.inspectObjectPrototype === true) {\n    tokenizePrototype(value, parser, {\n      membersToIgnore: ObjectPrototypeKeys,\n    })\n  } else if (config.inspectObjectPrototype === 'unless-plain-object' && !is.plainObject(value)) {\n    tokenizePrototype(value, parser, {\n      membersToIgnore: ObjectPrototypeKeys,\n      prototypeToIgnore: ObjectPrototype,\n    })\n  }\n\n  parser.collect({ type: 'object-end' })\n\n  /**\n   * Decrement depth and untrack seen object\n   */\n  parser.context.depth--\n  parser.context.objectsSeen.delete(value)\n}\n\n/**\n * Tokenizes the prototype of a value by calling Object.getPrototypeOf\n * method on the value.\n */\nexport function tokenizePrototype(\n  value: any,\n  parser: Parser,\n  config: {\n    prototypeToIgnore?: any\n    membersToIgnore?: (string | symbol)[]\n    eagerGetters?: (string | symbol)[]\n  }\n) {\n  const prototypeChain: { proto: any; keys: (string | symbol)[] }[] = []\n\n  /**\n   * Looping through the entire prototype chain and collecting\n   * all the keys\n   */\n  for (\n    let proto = Object.getPrototypeOf(value);\n    proto && (!config.prototypeToIgnore || proto !== config.prototypeToIgnore);\n    proto = Object.getPrototypeOf(proto)\n  ) {\n    let keys = Reflect.ownKeys(proto)\n\n    /**\n     * Remove keys when membersToIgnore properties are defined\n     */\n    if (config.membersToIgnore) {\n      const keysSet = new Set([...keys])\n      config.membersToIgnore.forEach((m) => keysSet.delete(m))\n      keys = Array.from(keysSet)\n    }\n\n    prototypeChain.push({ proto, keys })\n  }\n\n  if (!prototypeChain.length) {\n    return\n  }\n\n  const eagerGetters = config.eagerGetters ?? []\n  parser.collect({ type: 'prototype-start' })\n\n  /**\n   * Looping over own keys (including non-enumerable)\n   */\n  for (let proto of prototypeChain) {\n    for (let key of proto.keys) {\n      /**\n       * Ignore constructor\n       */\n      if (key === 'constructor') {\n        continue\n      }\n\n      /**\n       * Ensure property is known\n       */\n      const descriptor = Object.getOwnPropertyDescriptor(proto.proto, key)\n      if (!descriptor) {\n        continue\n      }\n\n      /**\n       * Collect key with its meta-data\n       */\n      const isSymbol = typeof key === 'symbol'\n      const isWritable = !!descriptor.set || !!descriptor.writable\n      parser.collect({\n        type: 'object-key',\n        isSymbol,\n        isWritable,\n        value: String(key),\n      })\n\n      /**\n       * Avoiding accessing getters to prevent\n       * side-effects\n       */\n      if ('get' in descriptor && !eagerGetters.includes(key)) {\n        parser.collect({ type: 'object-value-getter' })\n        continue\n      }\n\n      /**\n       * Inspect value\n       */\n      parser.collect({ type: 'object-value-start' })\n      parser.parse(value[key])\n      parser.collect({ type: 'object-value-end' })\n    }\n  }\n\n  parser.collect({ type: 'prototype-end' })\n}\n\n/**\n * Helper to tokenize array like values.\n */\nexport function tokenizeArray(\n  values:\n    | Array<any>\n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n    | BigInt64Array\n    | BigUint64Array,\n  parser: Parser,\n  config: {\n    name?: string\n    depth: number\n    collapse: string[]\n    inspectArrayPrototype: boolean\n    maxArrayLength: number\n  }\n) {\n  parser.context.arraysSeen = parser.context.arraysSeen ?? new Set()\n  parser.context.depth = parser.context.depth ?? 0\n\n  /**\n   * Handle circular references of the same array and\n   * limit traversing once maxDepth has been reached\n   */\n  if (parser.context.arraysSeen.has(values)) {\n    parser.collect({ type: 'array-circular-ref' })\n    return\n  }\n  if (parser.context.depth >= config.depth) {\n    parser.collect({ type: 'array-max-depth-ref' })\n    return\n  }\n\n  const limit = config.maxArrayLength\n  const size = values.length\n  const name = config.name || values.constructor.name\n\n  /**\n   * Do not inspect children when constructor of the\n   * array is meant to be collapsed.\n   */\n  if (config.collapse.includes(name)) {\n    parser.collect({\n      type: 'collapse',\n      name: name,\n      token: {\n        type: 'array-start',\n        name,\n        size,\n      },\n    })\n    return\n  }\n\n  /**\n   * Track seen array and increment depth\n   */\n  parser.context.depth++\n  parser.context.arraysSeen.add(values)\n\n  parser.collect({ type: 'array-start', name, size })\n\n  for (let index = 0; index < size; index++) {\n    if (index >= limit) {\n      parser.collect({ type: 'array-max-length-ref', limit, size })\n      break\n    }\n\n    const value = values[index]\n    if (Object.hasOwn(values, index)) {\n      parser.collect({ type: 'array-value-start', index })\n      parser.parse(value)\n      parser.collect({ type: 'array-value-end', index })\n    } else {\n      parser.collect({ type: 'array-value-hole', index })\n    }\n  }\n\n  /**\n   * Inspect prototype properties of the array\n   */\n  if (config.inspectArrayPrototype) {\n    tokenizePrototype(values, parser, {\n      membersToIgnore: ArrayPrototypeKeys,\n      prototypeToIgnore: ArrayPrototype,\n    })\n  }\n\n  parser.collect({ type: 'array-end', size })\n\n  /**\n   * Decrement depth and untrack seen array\n   */\n  parser.context.depth--\n  parser.context.arraysSeen.delete(values)\n}\n\n/**\n * HTML escape string values so that they can be nested\n * inside the pre-tags.\n */\nexport function htmlEscape(value: string): string {\n  return value\n    .replace(/&/g, '&amp;')\n    .replace(/\\\\\"/g, '&bsol;&quot;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\n\n/**\n * Wraps a string value to be on multiple lines after\n * a certain characters limit has been hit.\n */\nexport function wordWrap(\n  value: string,\n  options: {\n    width: number\n    indent: string\n    newLine: string\n    escape?: (value: string) => string\n  }\n) {\n  const width = options.width\n  const indent = options.indent\n  const newLine = `${options.newLine}${indent}`\n\n  let regexString = '.{1,' + width + '}'\n  regexString += '([\\\\s\\u200B]+|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]+|$)'\n\n  const re = new RegExp(regexString, 'g')\n  const lines = value.match(re) || []\n  const result = lines\n    .map(function (line) {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1)\n      }\n      return options.escape ? options.escape(line) : htmlEscape(line)\n    })\n    .join(newLine)\n\n  return result\n}\n","/*\n * @poppinss/dumper\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { inspect } from 'node:util'\nimport is, { type TypeName } from '@sindresorhus/is'\n\nimport { Parser } from '../parser.js'\nimport type { Tokenizer } from '../types.js'\nimport { tokenizeArray, tokenizeObject } from '../helpers.js'\n\n/**\n * Tokenizers are responsible for converting JS data types\n * to known dumper tokens.\n */\nexport const tokenizers: Partial<Record<TypeName, Tokenizer>> = {\n  /**\n   * Tokenizes an object and its properties.\n   *  - Enable \"showHidden\" option to parse non-enumerable\n   *  - Enable \"inspectObjectPrototype\" to parse prototype members\n   */\n  Object: (value: Record<string | symbol, any>, parser) => {\n    tokenizeObject(value, parser, parser.config)\n  },\n\n  /**\n   * Tokenizes an array of values\n   */\n  Array: (values: any[], parser) => {\n    tokenizeArray(values, parser, parser.config)\n  },\n\n  /**\n   * Tokenizes keys and values inside a map\n   */\n  Map: (values: Map<any, any>, parser) => {\n    parser.context.mapsSeen = parser.context.mapsSeen ?? new Set()\n    parser.context.depth = parser.context.depth ?? 0\n\n    /**\n     * Handle circular references of the same map and\n     * limit traversing once maxDepth has been reached\n     */\n    if (parser.context.mapsSeen.has(values)) {\n      parser.collect({ type: 'map-circular-ref' })\n      return\n    }\n    if (parser.context.depth >= parser.config.depth) {\n      parser.collect({ type: 'map-max-depth-ref' })\n      return\n    }\n\n    /**\n     * Track seen map and increment depth\n     */\n    parser.context.depth++\n    parser.context.mapsSeen.add(values)\n\n    let index = 0\n    const size = values.size\n    const limit = parser.config.maxArrayLength\n\n    parser.collect({ type: 'map-start', size })\n\n    for (let [key, value] of values) {\n      if (index >= limit) {\n        parser.collect({ type: 'map-max-length-ref', limit, size })\n        break\n      }\n\n      parser.collect({ type: 'map-row-start', index })\n\n      parser.collect({ type: 'map-key-start', index })\n      parser.parse(key)\n      parser.collect({ type: 'map-key-end', index })\n\n      parser.collect({ type: 'map-value-start', index })\n      parser.parse(value)\n      parser.collect({ type: 'map-value-end', index })\n      parser.collect({ type: 'map-row-end', index })\n      index++\n    }\n\n    parser.collect({ type: 'map-end', size })\n\n    /**\n     * Decrement depth and untrack seen map\n     */\n    parser.context.depth--\n    parser.context.mapsSeen.delete(values)\n  },\n\n  /**\n   * Tokenizes values inside a set\n   */\n  Set: (values: Set<any>, parser) => {\n    parser.context.setsSeen = parser.context.setsSeen ?? new Set()\n    parser.context.depth = parser.context.depth ?? 0\n\n    /**\n     * Handle circular references of the same set and\n     * limit traversing once maxDepth has been reached\n     */\n    if (parser.context.setsSeen.has(values)) {\n      parser.collect({ type: 'set-circular-ref' })\n      return\n    }\n    if (parser.context.depth >= parser.config.depth) {\n      parser.collect({ type: 'set-max-depth-ref' })\n      return\n    }\n\n    /**\n     * Track seen set and increment depth\n     */\n    parser.context.depth++\n    parser.context.setsSeen.add(values)\n\n    let index = 0\n    const size = values.size\n    const limit = parser.config.maxArrayLength\n\n    parser.collect({ type: 'set-start', size })\n\n    for (let value of values) {\n      if (index >= limit) {\n        parser.collect({ type: 'set-max-length-ref', limit, size })\n        break\n      }\n\n      parser.collect({ type: 'set-value-start', index })\n      parser.parse(value)\n      parser.collect({ type: 'set-value-end', index })\n      index++\n    }\n\n    parser.collect({ type: 'set-end', size })\n\n    /**\n     * Decrement depth and untrack seen set\n     */\n    parser.context.depth--\n    parser.context.setsSeen.delete(values)\n  },\n\n  /**\n   * Tokenizes a function. If the function is a class created\n   * using the [class] keyword, we will process its static\n   * members when \"config.inspectClassConstructor\"\n   * is enabled\n   */\n  Function: (value: Function, parser) => {\n    const ConstructorName = value.constructor.name\n    if (ConstructorName === 'GeneratorFunction') {\n      return tokenizers.GeneratorFunction!(value, parser)\n    }\n    if (ConstructorName === 'AsyncGeneratorFunction') {\n      return tokenizers.AsyncGeneratorFunction!(value, parser)\n    }\n    if (ConstructorName === 'AsyncFunction') {\n      return tokenizers.AsyncFunction!(value, parser)\n    }\n\n    const isClass = is.class(value)\n    parser.collect({\n      type: 'function',\n      isClass,\n      isAsync: false,\n      isGenerator: false,\n      name: value.name || 'anonymous',\n    })\n\n    /**\n     * Parsing static members of the class.\n     */\n    if (parser.config.inspectStaticMembers && isClass) {\n      parser.collect({ type: 'static-members-start' })\n\n      tokenizeObject(value, parser, {\n        showHidden: true,\n        depth: parser.config.depth,\n        inspectObjectPrototype: false,\n        collapse: parser.config.collapse,\n        membersToIgnore: ['prototype', 'name', 'length'],\n      })\n\n      parser.collect({ type: 'static-members-end' })\n    }\n  },\n\n  /**\n   * Tokenizes a string value and handles max length and\n   * correct quotes via the \"util.inspect\" method.\n   */\n  string: (value: string, parser) => {\n    const formatted = inspect(value, {\n      maxStringLength: parser.config.maxStringLength,\n      customInspect: false,\n    })\n    parser.collect({ type: 'string', value: formatted })\n  },\n\n  /**\n   * Tokenizes the URL instance as an object\n   */\n  URL: (value: URL, parser) => {\n    tokenizeObject(\n      {\n        hash: value.hash,\n        host: value.host,\n        hostname: value.hostname,\n        href: value.href,\n        origin: value.origin,\n        password: value.password,\n        pathname: value.pathname,\n        port: value.port,\n        protocol: value.protocol,\n        search: value.search,\n        searchParams: value.searchParams,\n        username: value.username,\n      },\n      parser,\n      { constructorName: 'URL', ...parser.config }\n    )\n  },\n\n  /**\n   * Tokenizes the URLSearchParams instance as an object\n   */\n  URLSearchParams: (value: URLSearchParams, parser) => {\n    tokenizeObject(Object.fromEntries(value), parser, {\n      constructorName: 'URLSearchParams',\n      ...parser.config,\n    })\n  },\n\n  Error: function (value: Error, parser: Parser): void {\n    tokenizeObject(value, parser, {\n      eagerGetters: ['message', 'stack'],\n      ...parser.config,\n      inspectObjectPrototype: parser.config.inspectObjectPrototype === true ? true : false,\n      showHidden: true,\n    })\n  },\n\n  FormData: function (value: FormData, parser: Parser): void {\n    tokenizeObject(Object.fromEntries(value.entries()), parser, {\n      constructorName: 'FormData',\n      ...parser.config,\n    })\n  },\n\n  /**\n   * Straight forward one's\n   */\n  undefined: (_, parser) => {\n    parser.collect({ type: 'undefined' })\n  },\n  null: (_, parser) => {\n    parser.collect({ type: 'null' })\n  },\n  symbol: (value: Symbol, parser) => {\n    parser.collect({ type: 'symbol', value: String(value) })\n  },\n  number: (value: number, parser) => {\n    parser.collect({ type: 'number', value })\n  },\n  boolean: (value: boolean, parser) => {\n    parser.collect({ type: 'boolean', value })\n  },\n  bigint: (value: BigInt, parser) => {\n    parser.collect({ type: 'bigInt', value: `${value.toString()}n` })\n  },\n  Date: (value: Date, parser) => {\n    parser.collect({ type: 'date', value: value.toISOString() })\n  },\n  RegExp: (value: RegExp, parser) => {\n    parser.collect({ type: 'regexp', value: String(value) })\n  },\n  Buffer: (value: Buffer, parser) => {\n    parser.collect({\n      type: 'buffer',\n      value: inspect(value),\n    })\n  },\n  WeakSet: (_, parser) => {\n    parser.collect({ type: 'weak-set' })\n  },\n  WeakMap: (_, parser) => {\n    parser.collect({ type: 'weak-map' })\n  },\n  WeakRef: function (_, parser: Parser): void {\n    parser.collect({ type: 'weak-ref' })\n  },\n  Generator: function (_, parser: Parser): void {\n    parser.collect({ type: 'generator', isAsync: false })\n  },\n  AsyncGenerator: function (_, parser: Parser): void {\n    parser.collect({ type: 'generator', isAsync: true })\n  },\n  GeneratorFunction: function (value: GeneratorFunction, parser: Parser): void {\n    parser.collect({\n      type: 'function',\n      isGenerator: true,\n      isClass: false,\n      isAsync: false,\n      name: value.name || 'anonymous',\n    })\n  },\n  AsyncGeneratorFunction: function (value: AsyncGeneratorFunction, parser: Parser): void {\n    parser.collect({\n      type: 'function',\n      isGenerator: true,\n      isClass: false,\n      isAsync: true,\n      name: value.name || 'anonymous',\n    })\n  },\n  AsyncFunction: function (value: Function, parser: Parser): void {\n    parser.collect({\n      type: 'function',\n      isGenerator: false,\n      isClass: false,\n      isAsync: true,\n      name: value.name || 'anonymous',\n    })\n  },\n  Observable: function (_, parser: Parser): void {\n    parser.collect({ type: 'observable' })\n  },\n  Blob: function (value: Blob, parser: Parser): void {\n    parser.collect({ type: 'blob', size: value.size, contentType: value.type })\n  },\n  Promise: function (value: Promise<any>, parser: Parser): void {\n    parser.collect({\n      type: 'promise',\n      isFulfilled: !inspect(value).includes('pending'),\n    })\n  },\n  NaN: function (_: number, parser: Parser): void {\n    parser.collect({ type: 'number', value: Number.NaN })\n  },\n  Int8Array: function (value: Int8Array, parser: Parser): void {\n    tokenizeArray(value, parser, parser.config)\n  },\n  Uint8Array: function (value: Uint8Array, parser: Parser): void {\n    tokenizeArray(value, parser, parser.config)\n  },\n  Int16Array: function (value: Int16Array, parser: Parser): void {\n    tokenizeArray(value, parser, parser.config)\n  },\n  Uint16Array: function (value: Uint16Array, parser: Parser): void {\n    tokenizeArray(value, parser, parser.config)\n  },\n  Int32Array: function (value: Int32Array, parser: Parser): void {\n    tokenizeArray(value, parser, parser.config)\n  },\n  Uint32Array: function (value: Uint32Array, parser: Parser): void {\n    tokenizeArray(value, parser, parser.config)\n  },\n  Float32Array: function (value: Float32Array, parser: Parser): void {\n    tokenizeArray(value, parser, parser.config)\n  },\n  Float64Array: function (value: Float64Array, parser: Parser): void {\n    tokenizeArray(value, parser, parser.config)\n  },\n  BigInt64Array: function (value: BigInt64Array, parser: Parser): void {\n    tokenizeArray(value, parser, parser.config)\n  },\n  BigUint64Array: function (value: BigUint64Array, parser: Parser): void {\n    tokenizeArray(value, parser, parser.config)\n  },\n}\n","/*\n * @poppinss/dumper\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport is, { TypeName } from '@sindresorhus/is'\nimport { tokenizers } from './tokenizers/main.js'\nimport type { ParserConfig, Token } from './types.js'\n\n/**\n * Parser is used to parse a JavaScript value into a set\n * of tokens that can be used to pretty-print the same\n * value.\n *\n * @example\n * ```ts\n * import { Parser } from '@poppinss/dumper'\n *\n * const parser = new Parser()\n * const value = {\n *   id: 1,\n *   username: 'foo',\n * }\n *\n * parser.parse(value)\n * parser.flush() // Token[]\n * ```\n */\nexport class Parser {\n  #tokens: Token[] = []\n\n  /**\n   * Config shared with tokenizers\n   */\n  config: Readonly<Required<ParserConfig>>\n\n  /**\n   * Context maintained through out the parsing phase.\n   * Each instance of Parser has its own context\n   * that gets mutated internally.\n   */\n  context: Record<string, any>\n\n  constructor(config?: ParserConfig, context?: Record<string, any>) {\n    this.context = context || {}\n    this.config = Object.freeze({\n      showHidden: false,\n      depth: 5,\n      inspectObjectPrototype: 'unless-plain-object',\n      inspectArrayPrototype: false,\n      inspectStaticMembers: false,\n      maxArrayLength: 100,\n      maxStringLength: 1000,\n      collapse: [],\n      ...config,\n    })\n  }\n\n  /**\n   * Normalizes the type name of a property using additional\n   * bit of checks. For example, the \"is\" module does not\n   * use instanceOf checks and hence misses out on many\n   * potentional improvements.\n   */\n  #normalizeTypeName(name: TypeName, value: any): TypeName {\n    if (name === 'Object' && value instanceof Error) {\n      return 'Error'\n    }\n    return name\n  }\n\n  /**\n   * Collect a token inside the list of tokens. The order\n   * of tokens matter during printing therefore you must\n   * collect tokens in the right order.\n   */\n  collect(token: Token) {\n    this.#tokens.push(token)\n  }\n\n  /**\n   * Parses a value using the tokenizers. Under the hood the\n   * tokenizers will call \"parser.collect\" to collect\n   * tokens inside an array.\n   *\n   * You can use \"parser.flush\" method to get the list of\n   * tokens.\n   */\n  parse(value: unknown) {\n    const typeName = this.#normalizeTypeName(is.detect(value), value)\n    const tokenizer = tokenizers[typeName]\n    if (tokenizer) {\n      tokenizer(value, this)\n    } else {\n      this.collect({ type: 'unknown', jsType: typeName, value })\n    }\n  }\n\n  /**\n   * Returns collected tokens and resets the internal state.\n   */\n  flush() {\n    const tokens = this.#tokens\n    this.#tokens = []\n    this.context = {}\n    return tokens\n  }\n}\n"],"mappings":"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","names":["is","is","is","is"]}