{"version":3,"sources":["../src/exception.ts"],"sourcesContent":["/*\n * @poppinss/utils\n *\n * (c) Poppinss\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { format } from 'node:util'\n\n/**\n * Extended Error object with the option to set error `status` and `code`.\n * At AdonisJs, we prefer exceptions with proper error codes to handle\n * them without relying on message pattern matching.\n *\n * ```js\n * new Exception('message', 500, 'E_RUNTIME_EXCEPTION')\n * ```\n */\nexport class Exception extends Error {\n  /**\n   * Static properties to defined on the exception once\n   * and then re-use them\n   */\n  declare static help?: string\n  declare static code?: string\n  declare static status?: number\n  declare static message?: string\n\n  /**\n   * Name of the class that raised the exception.\n   */\n  name: string\n\n  /**\n   * Optional help description for the error. You can use it to define additional\n   * human readable information for the error.\n   */\n  declare help?: string\n\n  /**\n   * A machine readable error code. This will allow the error handling logic\n   * to narrow down exceptions based upon the error code.\n   */\n  declare code?: string\n\n  /**\n   * A status code for the error. Usually helpful when converting errors\n   * to HTTP responses.\n   */\n  status: number\n\n  constructor(message?: string, options?: ErrorOptions & { code?: string; status?: number }) {\n    super(message, options)\n\n    const ErrorConstructor = this.constructor as typeof Exception\n\n    this.name = ErrorConstructor.name\n    this.message = message || ErrorConstructor.message || ''\n    this.status = options?.status || ErrorConstructor.status || 500\n\n    const code = options?.code || ErrorConstructor.code\n    if (code !== undefined) {\n      this.code = code\n    }\n\n    const help = ErrorConstructor.help\n    if (help !== undefined) {\n      this.help = help\n    }\n\n    Error.captureStackTrace(this, ErrorConstructor)\n  }\n\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  toString() {\n    if (this.code) {\n      return `${this.name} [${this.code}]: ${this.message}`\n    }\n    return `${this.name}: ${this.message}`\n  }\n}\n\n/**\n * Helper to create anonymous error classes\n */\nexport function createError<T extends any[] = never>(\n  message: string,\n  code: string,\n  status?: number\n): typeof Exception & T extends never\n  ? { new (args?: any, options?: ErrorOptions): Exception }\n  : { new (args: T, options?: ErrorOptions): Exception } {\n  return class extends Exception {\n    static message = message\n    static code = code\n    static status = status\n\n    constructor(args: T, options?: ErrorOptions) {\n      super(format(message, ...(args || [])), options)\n      this.name = 'Exception'\n    }\n  }\n}\n"],"mappings":";AASA,SAAS,cAAc;AAWhB,IAAM,YAAN,cAAwB,MAAM;AAAA;AAAA;AAAA;AAAA,EAanC;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA;AAAA,EAEA,YAAY,SAAkB,SAA6D;AACzF,UAAM,SAAS,OAAO;AAEtB,UAAM,mBAAmB,KAAK;AAE9B,SAAK,OAAO,iBAAiB;AAC7B,SAAK,UAAU,WAAW,iBAAiB,WAAW;AACtD,SAAK,SAAS,SAAS,UAAU,iBAAiB,UAAU;AAE5D,UAAM,OAAO,SAAS,QAAQ,iBAAiB;AAC/C,QAAI,SAAS,QAAW;AACtB,WAAK,OAAO;AAAA,IACd;AAEA,UAAM,OAAO,iBAAiB;AAC9B,QAAI,SAAS,QAAW;AACtB,WAAK,OAAO;AAAA,IACd;AAEA,UAAM,kBAAkB,MAAM,gBAAgB;AAAA,EAChD;AAAA,EAEA,KAAK,OAAO,WAAW,IAAI;AACzB,WAAO,KAAK,YAAY;AAAA,EAC1B;AAAA,EAEA,WAAW;AACT,QAAI,KAAK,MAAM;AACb,aAAO,GAAG,KAAK,IAAI,KAAK,KAAK,IAAI,MAAM,KAAK,OAAO;AAAA,IACrD;AACA,WAAO,GAAG,KAAK,IAAI,KAAK,KAAK,OAAO;AAAA,EACtC;AACF;AAKO,SAAS,YACd,SACA,MACA,QAGuD;AACvD,SAAO,cAAc,UAAU;AAAA,IAC7B,OAAO,UAAU;AAAA,IACjB,OAAO,OAAO;AAAA,IACd,OAAO,SAAS;AAAA,IAEhB,YAAY,MAAS,SAAwB;AAC3C,YAAM,OAAO,SAAS,GAAI,QAAQ,CAAC,CAAE,GAAG,OAAO;AAC/C,WAAK,OAAO;AAAA,IACd;AAAA,EACF;AACF;","names":[]}