{"version":3,"sources":["../../../src/plugins/edge.ts"],"sourcesContent":["/*\n * @adonisjs/vite\n *\n * (c) AdonisJS\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport type { Edge } from 'edge.js'\nimport { EdgeError } from 'edge-error'\nimport type { PluginFn } from 'edge.js/types'\n\nimport type { Vite } from '../vite.js'\n\n/**\n * The edge plugin for vite to share vite service with edge\n * and register custom tags\n */\nexport const edgePluginVite: (vite: Vite) => PluginFn<undefined> = (vite) => {\n  const edgeVite = (edge: Edge) => {\n    edge.global('vite', vite)\n    edge.global('asset', vite.assetPath.bind(vite))\n\n    edge.registerTag({\n      tagName: 'viteReactRefresh',\n      seekable: true,\n      block: false,\n      compile(parser, buffer, token) {\n        let attributes = ''\n        if (token.properties.jsArg.trim()) {\n          /**\n           * Converting a single argument to a SequenceExpression so that we\n           * work around the following edge cases.\n           *\n           * - If someone passes an object literal to the tag, ie { nonce: 'foo' }\n           *   it will be parsed as a LabeledStatement and not an object.\n           * - If we wrap the object literal inside parenthesis, ie ({nonce: 'foo'})\n           *   then we will end up messing other expressions like a variable reference\n           *   , or a member expression and so on.\n           * - So the best bet is to convert user supplied argument to a sequence expression\n           *   and hence ignore it during stringification.\n           */\n          const jsArg = `a,${token.properties.jsArg}`\n\n          const parsed = parser.utils.transformAst(\n            parser.utils.generateAST(jsArg, token.loc, token.filename),\n            token.filename,\n            parser\n          )\n          attributes = parser.utils.stringify(parsed.expressions[1])\n        }\n\n        /**\n         * Get HMR script\n         */\n        buffer.writeExpression(\n          `const __vite_hmr_script = state.vite.getReactHmrScript(${attributes})`,\n          token.filename,\n          token.loc.start.line\n        )\n\n        /**\n         * Check if the script exists (only in hot mode)\n         */\n        buffer.writeStatement('if(__vite_hmr_script) {', token.filename, token.loc.start.line)\n\n        /**\n         * Write output\n         */\n        buffer.outputExpression(\n          `__vite_hmr_script.toString()`,\n          token.filename,\n          token.loc.start.line,\n          false\n        )\n\n        /**\n         * Close if block\n         */\n        buffer.writeStatement('}', token.filename, token.loc.start.line)\n      },\n    })\n\n    edge.registerTag({\n      tagName: 'vite',\n      seekable: true,\n      block: false,\n      compile(parser, buffer, token) {\n        /**\n         * Ensure an argument is defined\n         */\n        if (!token.properties.jsArg.trim()) {\n          throw new EdgeError('Missing entrypoint name', 'E_RUNTIME_EXCEPTION', {\n            filename: token.filename,\n            line: token.loc.start.line,\n            col: token.loc.start.col,\n          })\n        }\n\n        const parsed = parser.utils.transformAst(\n          parser.utils.generateAST(token.properties.jsArg, token.loc, token.filename),\n          token.filename,\n          parser\n        )\n\n        const entrypoints = parser.utils.stringify(parsed)\n        const methodCall =\n          parsed.type === 'SequenceExpression'\n            ? `generateEntryPointsTags${entrypoints}`\n            : `generateEntryPointsTags(${entrypoints})`\n\n        buffer.outputExpression(\n          `(await state.vite.${methodCall}).join('\\\\n')`,\n          token.filename,\n          token.loc.start.line,\n          false\n        )\n      },\n    })\n  }\n\n  return edgeVite\n}\n"],"mappings":";AAUA,SAAS,iBAAiB;AASnB,IAAM,iBAAsD,CAAC,SAAS;AAC3E,QAAM,WAAW,CAAC,SAAe;AAC/B,SAAK,OAAO,QAAQ,IAAI;AACxB,SAAK,OAAO,SAAS,KAAK,UAAU,KAAK,IAAI,CAAC;AAE9C,SAAK,YAAY;AAAA,MACf,SAAS;AAAA,MACT,UAAU;AAAA,MACV,OAAO;AAAA,MACP,QAAQ,QAAQ,QAAQ,OAAO;AAC7B,YAAI,aAAa;AACjB,YAAI,MAAM,WAAW,MAAM,KAAK,GAAG;AAajC,gBAAM,QAAQ,KAAK,MAAM,WAAW,KAAK;AAEzC,gBAAM,SAAS,OAAO,MAAM;AAAA,YAC1B,OAAO,MAAM,YAAY,OAAO,MAAM,KAAK,MAAM,QAAQ;AAAA,YACzD,MAAM;AAAA,YACN;AAAA,UACF;AACA,uBAAa,OAAO,MAAM,UAAU,OAAO,YAAY,CAAC,CAAC;AAAA,QAC3D;AAKA,eAAO;AAAA,UACL,0DAA0D,UAAU;AAAA,UACpE,MAAM;AAAA,UACN,MAAM,IAAI,MAAM;AAAA,QAClB;AAKA,eAAO,eAAe,2BAA2B,MAAM,UAAU,MAAM,IAAI,MAAM,IAAI;AAKrF,eAAO;AAAA,UACL;AAAA,UACA,MAAM;AAAA,UACN,MAAM,IAAI,MAAM;AAAA,UAChB;AAAA,QACF;AAKA,eAAO,eAAe,KAAK,MAAM,UAAU,MAAM,IAAI,MAAM,IAAI;AAAA,MACjE;AAAA,IACF,CAAC;AAED,SAAK,YAAY;AAAA,MACf,SAAS;AAAA,MACT,UAAU;AAAA,MACV,OAAO;AAAA,MACP,QAAQ,QAAQ,QAAQ,OAAO;AAI7B,YAAI,CAAC,MAAM,WAAW,MAAM,KAAK,GAAG;AAClC,gBAAM,IAAI,UAAU,2BAA2B,uBAAuB;AAAA,YACpE,UAAU,MAAM;AAAA,YAChB,MAAM,MAAM,IAAI,MAAM;AAAA,YACtB,KAAK,MAAM,IAAI,MAAM;AAAA,UACvB,CAAC;AAAA,QACH;AAEA,cAAM,SAAS,OAAO,MAAM;AAAA,UAC1B,OAAO,MAAM,YAAY,MAAM,WAAW,OAAO,MAAM,KAAK,MAAM,QAAQ;AAAA,UAC1E,MAAM;AAAA,UACN;AAAA,QACF;AAEA,cAAM,cAAc,OAAO,MAAM,UAAU,MAAM;AACjD,cAAM,aACJ,OAAO,SAAS,uBACZ,0BAA0B,WAAW,KACrC,2BAA2B,WAAW;AAE5C,eAAO;AAAA,UACL,qBAAqB,UAAU;AAAA,UAC/B,MAAM;AAAA,UACN,MAAM,IAAI,MAAM;AAAA,UAChB;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;","names":[]}