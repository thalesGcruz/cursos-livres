import { ConfigProvider } from '@adonisjs/core/types';
import { HttpContext } from '@adonisjs/core/http';
import { Simplify, Serialize } from '@tuyau/utils/types';
import { Vite } from '@adonisjs/vite';

/**
 * Symbol used to identify lazy props
 */
declare const kLazySymbol: unique symbol;
/**
 * Main class used to interact with Inertia
 */
declare class Inertia {
    #private;
    protected ctx: HttpContext;
    protected config: ResolvedConfig;
    protected vite?: Vite | undefined;
    constructor(ctx: HttpContext, config: ResolvedConfig, vite?: Vite | undefined);
    /**
     * Share data for the current request.
     * This data will override any shared data defined in the config.
     */
    share(data: Record<string, Data>): void;
    /**
     * Render a page using Inertia
     */
    render<TPageProps extends Record<string, any> = {}, TViewProps extends Record<string, any> = {}>(component: string, pageProps?: TPageProps, viewProps?: TViewProps): Promise<string | PageObject<TPageProps>>;
    /**
     * Create a lazy prop
     *
     * Lazy props are never resolved on first visit, but only when the client
     * request a partial reload explicitely with this value.
     *
     * See https://inertiajs.com/partial-reloads#lazy-data-evaluation
     */
    lazy<T>(callback: () => MaybePromise<T>): {
        [kLazySymbol]: () => MaybePromise<T>;
    };
    /**
     * This method can be used to redirect the user to an external website
     * or even a non-inertia route of your application.
     *
     * See https://inertiajs.com/redirects#external-redirects
     */
    location(url: string): Promise<void>;
}

/**
 * VersionCache is used to cache the version of the assets.
 *
 * If the user has provided a version, it will be used.
 * Otherwise, we will compute a hash from the manifest file
 * and cache it.
 */
declare class VersionCache {
    #private;
    protected appRoot: URL;
    protected assetsVersion?: AssetsVersion;
    constructor(appRoot: URL, assetsVersion?: AssetsVersion);
    /**
     * Pre-compute the version
     */
    computeVersion(): Promise<this>;
    /**
     * Returns the current assets version
     */
    getVersion(): string | number;
    /**
     * Set the assets version
     */
    setVersion(version: AssetsVersion): Promise<void>;
}

type MaybePromise<T> = T | Promise<T>;
/**
 * Props that will be passed to inertia render method
 */
type PageProps = Record<string, unknown>;
/**
 * Shared data types
 */
type Data = string | number | object | boolean;
type SharedDatumFactory = (ctx: HttpContext) => MaybePromise<Data>;
type SharedData = Record<string, Data | SharedDatumFactory>;
/**
 * Allowed values for the assets version
 */
type AssetsVersion = string | number | undefined;
interface InertiaConfig<T extends SharedData = SharedData> {
    /**
     * Path to the Edge view that will be used as the root view for Inertia responses.
     * @default root (resources/views/inertia_layout.edge)
     */
    rootView?: string | ((ctx: HttpContext) => string);
    /**
     * Path to your client-side entrypoint file.
     */
    entrypoint?: string;
    /**
     * The version of your assets. Every client request will be checked against this version.
     * If the version is not the same, the client will do a full reload.
     */
    assetsVersion?: AssetsVersion;
    /**
     * Data that should be shared with all rendered pages
     */
    sharedData?: T;
    /**
     * Options to configure SSR
     */
    ssr?: {
        /**
         * Enable or disable SSR
         */
        enabled: boolean;
        /**
         * List of components that should be rendered on the server
         */
        pages?: string[] | ((ctx: HttpContext, page: string) => MaybePromise<boolean>);
        /**
         * Path to the SSR entrypoint file
         */
        entrypoint?: string;
        /**
         * Path to the SSR bundled file that will be used in production
         */
        bundle?: string;
    };
}
/**
 * Resolved inertia configuration
 */
interface ResolvedConfig<T extends SharedData = SharedData> {
    rootView: string | ((ctx: HttpContext) => string);
    versionCache: VersionCache;
    sharedData: T;
    ssr: {
        enabled: boolean;
        entrypoint: string;
        pages?: string[] | ((ctx: HttpContext, page: string) => MaybePromise<boolean>);
        bundle: string;
    };
}
interface PageObject<TPageProps extends PageProps = PageProps> {
    component: string;
    version: string | number;
    props: TPageProps;
    url: string;
    ssrHead?: string;
    ssrBody?: string;
}
type IsLazyProp<T> = T extends {
    [kLazySymbol]: () => MaybePromise<any>;
} ? true : false;
type InferProps<T> = {
    [K in keyof T as IsLazyProp<T[K]> extends true ? K : never]+?: T[K] extends {
        [kLazySymbol]: () => MaybePromise<infer U>;
    } ? U : T[K];
} & {
    [K in keyof T as IsLazyProp<T[K]> extends true ? never : K]: T[K];
};
type ReturnsTypesSharedData<T extends SharedData> = {} extends T ? {} : {
    [K in keyof T]: T[K] extends (...args: any[]) => MaybePromise<infer U> ? U : T[K];
};
/**
 * Infer shared data types from the config provider
 */
type InferSharedProps<T extends ConfigProvider<ResolvedConfig>> = ReturnsTypesSharedData<Awaited<ReturnType<T['resolver']>>['sharedData']>;
/**
 * The shared props inferred from the user config user-land.
 * Should be module augmented by the user
 */
interface SharedProps {
}
/**
 * Helper for infering the page props from a Controller method that returns
 * inertia.render
 *
 * InferPageProps will also include the shared props
 *
 * ```ts
 * // Your Adonis Controller
 * class MyController {
 *  index() {
 *   return inertia.render('foo', { foo: 1 })
 *  }
 * }
 *
 * // Your React component
 * export default MyReactComponent(props: InferPageProps<Controller, 'index'>) {
 * }
 * ```
 */
type InferPageProps<Controller, Method extends keyof Controller> = Controller[Method] extends (...args: any[]) => any ? Simplify<Serialize<InferProps<Extract<Awaited<ReturnType<Controller[Method]>>, PageObject>['props']> & SharedProps>> : never;
/**
 * Signature for the method in the SSR entrypoint file
 */
type RenderInertiaSsrApp = (page: PageObject) => Promise<{
    head: string[];
    body: string;
}>;

export { type AssetsVersion as A, type Data as D, type InertiaConfig as I, type MaybePromise as M, type PageProps as P, type ResolvedConfig as R, type SharedData as S, Inertia as a, type SharedDatumFactory as b, type PageObject as c, type InferSharedProps as d, type SharedProps as e, type InferPageProps as f, type RenderInertiaSsrApp as g };
