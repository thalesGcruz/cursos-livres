import {
  makeAttributes,
  uniqBy
} from "./chunk-CFRBPZ4N.js";

// src/vite.ts
import { join } from "node:path";
import { readFileSync } from "node:fs";
import { slash } from "@poppinss/utils";
var styleFileRegex = /\.(css|less|sass|scss|styl|stylus|pcss|postcss)($|\?)/;
var Vite = class {
  constructor(isViteRunning, options) {
    this.isViteRunning = isViteRunning;
    this.#options = options;
    this.#options.assetsUrl = (this.#options.assetsUrl || "/").replace(/\/$/, "");
  }
  /**
   * We cache the manifest file content in production
   * to avoid reading the file multiple times
   */
  #manifestCache;
  #options;
  #devServer;
  #createServerPromise;
  /**
   * Reads the file contents as JSON
   */
  #readFileAsJSON(filePath) {
    return JSON.parse(readFileSync(filePath, "utf-8"));
  }
  /**
   * Generates a JSON element with a custom toString implementation
   */
  #generateElement(element) {
    return {
      ...element,
      toString() {
        const attributes = `${makeAttributes(element.attributes)}`;
        if (element.tag === "link") {
          return `<${element.tag} ${attributes}/>`;
        }
        return `<${element.tag} ${attributes}>${element.children.join("\n")}</${element.tag}>`;
      }
    };
  }
  /**
   * Returns the script needed for the HMR working with Vite
   */
  #getViteHmrScript(attributes) {
    return this.#generateElement({
      tag: "script",
      attributes: {
        type: "module",
        src: "/@vite/client",
        ...attributes
      },
      children: []
    });
  }
  /**
   * Check if the given path is a CSS path
   */
  #isCssPath(path) {
    return path.match(styleFileRegex) !== null;
  }
  /**
   * If the module is a style module
   */
  #isStyleModule(mod) {
    if (this.#isCssPath(mod.url) || mod.id && /\?vue&type=style/.test(mod.id)) {
      return true;
    }
    return false;
  }
  /**
   * Unwrap attributes from the user defined function or return
   * the attributes as it is
   */
  #unwrapAttributes(src, url, attributes) {
    if (typeof attributes === "function") {
      return attributes({ src, url });
    }
    return attributes;
  }
  /**
   * Create a style tag for the given path
   */
  #makeStyleTag(src, url, attributes) {
    const customAttributes = this.#unwrapAttributes(src, url, this.#options?.styleAttributes);
    return this.#generateElement({
      tag: "link",
      attributes: { rel: "stylesheet", ...customAttributes, ...attributes, href: url }
    });
  }
  /**
   * Create a script tag for the given path
   */
  #makeScriptTag(src, url, attributes) {
    const customAttributes = this.#unwrapAttributes(src, url, this.#options?.scriptAttributes);
    return this.#generateElement({
      tag: "script",
      attributes: { type: "module", ...customAttributes, ...attributes, src: url },
      children: []
    });
  }
  /**
   * Generate an asset URL for a given asset path
   */
  #generateAssetUrl(path) {
    return `${this.#options.assetsUrl}/${path}`;
  }
  /**
   * Generate a HTML tag for the given asset
   */
  #generateTag(asset, attributes) {
    let url = "";
    if (this.isViteRunning) {
      url = `/${asset}`;
    } else {
      url = this.#generateAssetUrl(asset);
    }
    if (this.#isCssPath(asset)) {
      return this.#makeStyleTag(asset, url, attributes);
    }
    return this.#makeScriptTag(asset, url, attributes);
  }
  /**
   * Collect CSS files from the module graph recursively
   */
  #collectCss(mod, styleUrls, visitedModules, importer) {
    if (!mod.url)
      return;
    if (visitedModules.has(mod.url))
      return;
    visitedModules.add(mod.url);
    if (this.#isStyleModule(mod) && (!importer || !this.#isStyleModule(importer))) {
      if (mod.url.startsWith("/")) {
        styleUrls.add(mod.url);
      } else if (mod.url.startsWith("\0")) {
        styleUrls.add(`/@id/__x00__${mod.url.substring(1)}`);
      } else {
        styleUrls.add(`/@id/${mod.url}`);
      }
    }
    mod.importedModules.forEach((dep) => this.#collectCss(dep, styleUrls, visitedModules, mod));
  }
  /**
   * Generate style and script tags for the given entrypoints
   * Also adds the @vite/client script
   */
  async #generateEntryPointsTagsForDevMode(entryPoints, attributes) {
    const server = this.getDevServer();
    const tags = entryPoints.map((entrypoint) => this.#generateTag(entrypoint, attributes));
    const jsEntrypoints = entryPoints.filter((entrypoint) => !this.#isCssPath(entrypoint));
    if (server?.moduleGraph.idToModuleMap.size === 0) {
      await Promise.allSettled(
        jsEntrypoints.map((entrypoint) => server.warmupRequest(`/${entrypoint}`))
      );
    }
    const preloadUrls = /* @__PURE__ */ new Set();
    const visitedModules = /* @__PURE__ */ new Set();
    const cssTagsElement = /* @__PURE__ */ new Set();
    for (const entryPoint of jsEntrypoints) {
      const filePath = join(server.config.root, entryPoint);
      const entryMod = server.moduleGraph.getModuleById(slash(filePath));
      if (entryMod)
        this.#collectCss(entryMod, preloadUrls, visitedModules);
    }
    const elements = Array.from(preloadUrls).map(
      (href) => this.#generateElement({
        tag: "link",
        attributes: { rel: "stylesheet", as: "style", href }
      })
    );
    elements.forEach((element) => cssTagsElement.add(element));
    const viteHmr = this.#getViteHmrScript(attributes);
    const result = [...cssTagsElement, viteHmr].concat(tags);
    return result.sort((tag) => tag.tag === "link" ? -1 : 1);
  }
  /**
   * Get a chunk from the manifest file for a given file name
   */
  #chunk(manifest, entrypoint) {
    const chunk = manifest[entrypoint];
    if (!chunk) {
      throw new Error(`Cannot find "${entrypoint}" chunk in the manifest file`);
    }
    return chunk;
  }
  /**
   * Get a list of chunks for a given filename
   */
  #chunksByFile(manifest, file) {
    return Object.entries(manifest).filter(([, chunk]) => chunk.file === file).map(([_, chunk]) => chunk);
  }
  /**
   * Generate preload tag for a given url
   */
  #makePreloadTagForUrl(url) {
    const attributes = this.#isCssPath(url) ? { rel: "preload", as: "style", href: url } : { rel: "modulepreload", href: url };
    return this.#generateElement({ tag: "link", attributes });
  }
  /**
   * Generate style and script tags for the given entrypoints
   * using the manifest file
   */
  #generateEntryPointsTagsWithManifest(entryPoints, attributes) {
    const manifest = this.manifest();
    const tags = [];
    const preloads = [];
    for (const entryPoint of entryPoints) {
      const chunk = this.#chunk(manifest, entryPoint);
      preloads.push({ path: this.#generateAssetUrl(chunk.file) });
      tags.push({
        path: chunk.file,
        tag: this.#generateTag(chunk.file, { ...attributes, integrity: chunk.integrity })
      });
      for (const css of chunk.css || []) {
        preloads.push({ path: this.#generateAssetUrl(css) });
        tags.push({ path: css, tag: this.#generateTag(css) });
      }
      for (const importNode of chunk.imports || []) {
        preloads.push({ path: this.#generateAssetUrl(manifest[importNode].file) });
        for (const css of manifest[importNode].css || []) {
          const subChunk = this.#chunksByFile(manifest, css);
          preloads.push({ path: this.#generateAssetUrl(css) });
          tags.push({
            path: this.#generateAssetUrl(css),
            tag: this.#generateTag(css, {
              ...attributes,
              integrity: subChunk[0]?.integrity
            })
          });
        }
      }
    }
    const preloadsElements = uniqBy(preloads, "path").sort((preload) => this.#isCssPath(preload.path) ? -1 : 1).map((preload) => this.#makePreloadTagForUrl(preload.path));
    return preloadsElements.concat(tags.map(({ tag }) => tag));
  }
  /**
   * Generate tags for the entry points
   */
  async generateEntryPointsTags(entryPoints, attributes) {
    entryPoints = Array.isArray(entryPoints) ? entryPoints : [entryPoints];
    if (this.isViteRunning) {
      return this.#generateEntryPointsTagsForDevMode(entryPoints, attributes);
    }
    return this.#generateEntryPointsTagsWithManifest(entryPoints, attributes);
  }
  /**
   * Returns the explicitly configured assetsUrl
   */
  assetsUrl() {
    return this.#options.assetsUrl;
  }
  /**
   * Returns path to a given asset file using the manifest file
   */
  assetPath(asset) {
    if (this.isViteRunning) {
      return `/${asset}`;
    }
    const chunk = this.#chunk(this.manifest(), asset);
    return this.#generateAssetUrl(chunk.file);
  }
  /**
   * Returns the manifest file contents
   *
   * @throws Will throw an exception when running in dev
   */
  manifest() {
    if (this.isViteRunning) {
      throw new Error("Cannot read the manifest file when running in dev mode");
    }
    if (!this.#manifestCache) {
      this.#manifestCache = this.#readFileAsJSON(this.#options.manifestFile);
    }
    return this.#manifestCache;
  }
  /**
   * Create the Vite Dev Server and runtime
   *
   * We lazy load the APIs to avoid loading it in production
   * since we don't need it
   */
  async createDevServer(options) {
    const { createServer } = await import("vite");
    this.#createServerPromise = createServer({
      server: { middlewareMode: true },
      appType: "custom",
      ...options
    });
    this.#devServer = await this.#createServerPromise;
  }
  /**
   * Create a runtime instance
   * Will not be available when running in production since
   * it needs the Vite Dev server
   */
  async createRuntime(options = {}) {
    const { createViteRuntime } = await import("vite");
    return createViteRuntime(this.#devServer, options);
  }
  /**
   * Stop the Vite Dev server
   */
  async stopDevServer() {
    await this.#createServerPromise;
    await this.#devServer?.close();
  }
  /**
   * Get the Vite Dev server instance
   * Will not be available when running in production
   */
  getDevServer() {
    return this.#devServer;
  }
  /**
   * Returns the script needed for the HMR working with React
   */
  getReactHmrScript(attributes) {
    if (!this.isViteRunning) {
      return null;
    }
    return this.#generateElement({
      tag: "script",
      attributes: {
        type: "module",
        ...attributes
      },
      children: [
        "",
        `import RefreshRuntime from '/@react-refresh'`,
        `RefreshRuntime.injectIntoGlobalHook(window)`,
        `window.$RefreshReg$ = () => {}`,
        `window.$RefreshSig$ = () => (type) => type`,
        `window.__vite_plugin_react_preamble_installed__ = true`,
        ""
      ]
    });
  }
};

export {
  Vite
};
//# sourceMappingURL=chunk-W6CJOSLQ.js.map